#740. 删除与获得点数

'''
给定一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1:

输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 来获得 4 个点数，因此 3 也被删除。
之后，删除 2 来获得 2 个点数。总共获得 6 个点数。
示例 2:

输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
'''

#动态规划
'''
题意实际上就是，如果选择了某个数字，那么他左右两边的数字就不能再选，那么题目就变成了打家劫舍的问题。
所谓打家劫舍问题其实就是小偷只能从相隔超过1的房子偷东西，最终求偷到的价值总和最大，也就是说不能偷相邻的房子。
打家劫舍问题的求解就可以转变成这样一个递推关系：dp[i] = max(dp[i-1],dp[i-2]+A[i]).

那么需要做的是就是先将本题转换成打家劫舍问题，接着就可以套用打家劫舍的问题就行求解。做法如下：
	1.遍历一遍原来的数组，找到最大值max，然后创建一个新数组，大小为max+1，其实下标对应数字，这样其实就是
	一种hashing的做法
	2.再遍历一遍原数组，然后根据这个修改新数组的元素，这样新数组每个数字就代表了对应当前下标的数字的价值总和
	3.问题转换为打家劫舍问题。注意此时我们构造出了一个有相邻关系的新数组。
'''


class Solution(object):
    def deleteAndEarn(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums or len(nums)==0:
        	return 0
        if len(nums)==1:
        	return nums[0]
        dp = [0]*(max(nums)+1)
        for num in nums:
        	dp[num]+=num
        return self.Rob(dp)

    def Rob(self,nums):
    	nums[1] = max(nums[0],nums[1])
    	for i in range(2,len(nums)):
    		nums[i] = max(nums[i-1],nums[i-2]+nums[i])
    	return nums[-1]




