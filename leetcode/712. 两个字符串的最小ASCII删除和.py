#712. 两个字符串的最小ASCII删除和

'''
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。

示例 1:

输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
'''

#动态规划
'''
记dp[i][j]为s1中第i个位置之前的字符串与s2中第j个位置之前的字符串保持相同需要删除的最小值（ascii码）
（注意，这里第i个位置表示s[i-1]）
那么接下来我们只需要找到一个递推关系，就可以用动态规划实现。

	1.首先，dp[i][j]可以由dp[i-1][j]得到，此时只是s1中多了一个字符(第i个位置这个字符)，删去这个字
	符串两个小字符串又能保持相同，因此有dp[i][j]=dp[i-1][j]+ord(s1[i-1])
	2.对应的，dp[i][j]=dp[i][j-1]+ord(s2[j-1])
	3.注意dp[i][j]还可以由dp[i-1][j-1]得到，这时候只要s1[i-1]==s2[j-1]即可，不需要删去任何字符，
	因此有dp[i][j]=dp[i-1][j-1]

综上所述，我们可以得到不同可能下的递推式，每次只需要判断新增加的两个字符是否相同，如果相同，那么下一个
dp数组的值和先前一样，如果不同，则需要在另外两种可能中选择较小者即可。
可以用动态规划实现，可以用一个(m+1)*(n+1)的二维数组保存dp[i][j]的值，注意初始值的设置（dp[0][j]以及
dp[i][0]）;接下来只需要逐行逐列的遍历数组，并根据上面的递推关系更新这个二维数组，最终在最右下角的位置
上的元素就是题目最终解。
	
'''

class Solution(object):
    def minimumDeleteSum(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: int
        """
        if not s1 or not s2 or s1==s2:
            return 0
        m,n = len(s1),len(s2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(1,m+1):
            dp[i][0]=dp[i-1][0]+ord(s1[i-1])
        for j in range(1,n+1):
            dp[0][j]=dp[0][j-1]+ord(s2[j-1]) 
        for i in range(1,m+1):
            for j in range(1,n+1):
                if s1[i-1]==s2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i-1][j]+ord(s1[i-1]),dp[i][j-1]+ord(s2[j-1]))
        return dp[m][n]