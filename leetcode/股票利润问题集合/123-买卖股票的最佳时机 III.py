#限制条件：最多完成两笔交易。
#求最大收益
#找两段不重叠的上升子序列，使得他们产生的收益和最大。

'''
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
'''


#解答：
'''
难点在于可以做两次交易，也就是说多了一些选择。题目可以看做是找两段不重叠的上升子序列，使得他们产生的收益和最大。
仿照T121，只能进行一次交易的那道题解法二的思路，我们这里采用四个变量记录，分别为：
	——buy1：第一次买入状态的最大收益
	——sell1：第一次卖出状态的最大收益
	——buy2：第二次买入状态的最大收益
	——sell2：第二次卖出状态的最大收益

那么遍历过程中我们按照下面思路更新四个变量：
	buy1 = max(buy1,-price)
	sell1 = max(sell1,buy+price)
	buy2 = max(buy2,sell1-price)   #两种选择，要么当前价格买入（=sell1-price），要么不做操作（=buy2）
	sell2 = max(sell2,buy2+price)	#两种选择，要么当前价格卖出（=buy2+price），要么不操作（=sell2）

举两个例子：
prices	1	2	3	4	5
b1     -1  -1  -1  -1  -1
s1      0   1   2   3   4
b2     -1  -1  -1  -1  -1
s2      0   1   2   3   4


prices  3	3	5	0	0	3	1	4
b1     -3  -3  -3   0   0   0   0   0
s1      0   0   2   2   2   3   3   4
b2     -3  -3  -3   2   2   2   2   2
s2      0   0   3   3   3   5   5   6
'''
def maxProfit(prices):
	if len(prices)<2:
		return 0
	buy1 = sell1 = buy2 = sell2 = float('-inf')
	for price in prices:
		buy1 = max(buy1,-price)
		sell1 = max(sell1,buy1+price)
		buy2 = max(buy2,sell1-price)
		sell2 = max(sell2,buy2+price)
	return sell2